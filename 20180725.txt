
事件
昨天睡前看了一下 没太看懂 好像是委托的应用
系统性学习走起吧
publisher-subscriber-enventhandler
发布者 订阅者 事件处理程序
看完概述 就差不多是委托 应该就是一般的触发机制
事件和事件处理程序同样保持一致的签名和返回类型 好像这时写作委托
关键字 event
事件不是类 是类或结构的成员 跟方法/属性一样
看下来好像也不是很难 不过图解教程这本书没练习 本身委托这些东西有些抽象理解了也不太会用 还是多做练习
含糊的看完了事件 感觉没用过还是太影响理解了
目前也没有遇到比较合适的场景 遇到了再回顾一下吧

接口
之前已经理解了 现在不细看了 目录里只有一两项不太清楚的
先说理解
接口就是约定好的一组函数成员 作用就是为了统一方便交换之类的 本质上就是个模板 所以不能实现
可以继承多个接口 只能派生接口
目录里两项不太清楚 实现具有重复成员的接口 as运算符
as应该强制转换差不多 不同的是 如果没有实现接口as表达式会返回null 强制转换会抛出异常
重复成员这个 书里讲的没看明白 就没写什么东西 最后成了什么样我也一脸懵逼
查了一下 书上讲的好像不太对 书上直接用类里面实现的成员 
网上查的是加个命名空间 interface1.method 和 interface2.method 这个样子
接口也就先到这 以后用的时候不熟再回顾

泛型
用<T>表示 感觉是一个非常好理解的概念 看看有啥骚操作吧
不是所有类都实现比大小 所以直接比大小的话会有编译错误
where子句
where TypeParam : constraint, constraint,...
用来对泛型进行约束
一共只有五种类型的约束
类名 class struct 接口名 new（）
两个名的意思是这个类或者接口的自己或子类才能用作类型实参
还能理解
class 任何引用类型 struct 任何值类型
new（）任何无参公共构造函数 （叫作 构造函数约束）
泛型方法
比一般方法多个<T>放参数（）前面
easy
调用泛型方法时就要提供类型实参
如果 public void MyMethod <T>(T myVal) { ....}
这种T一样 则调用时可省略为 MyMethod(myInt);
c#这种语法糖还挺合理挺舒服
泛型方法的限制 必须静态 第一个参数类型必须有this 这个this没明白
泛型委托 泛型结构 泛型接口
泛型接口要细讲一哈 接口可以有多个 泛型接口一样可以多个 而且同一个泛型接口用作不同类型算不同的
但如果用了两个同样类型的泛型接口就不行 等于只用了一个类型 但错写了一个
有点意思 没有想到 但合逻辑 没啥难理解的
