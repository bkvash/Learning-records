==========20180724===========
2018/7/24 2:00
刚明白C#里的委托是个啥意思
delegate void MyDel(int value);
应该是放方法的类 没有实现代码块
输出类型和输入参数的个数和类型定义了一个委托指定的方法
（刚看了眼书 输入参数的个数和类型 叫 签名 之前有印象）
委托可以看做一组方法的有序组合
调用委托就等于一个一个执行这组方法
添加用+= 删除用-=
当然委托是引用类型 对委托本身做改变不会影响包含的方法

如果委托有返回值并且有多个方法
那最后一个方法的返回值就是委托调用的返回值
emmmm..............
其他方法的调用值都会被忽略 这....
略不合逻辑 我以为会返回个数组之类的

如果委托有引用参数（ref）
ref的新值会传到下一个方法......行吧

匿名方法
只会被使用一次 用来初始化委托？避免了创建独立的具体名称的方法
大概理解了 还不知道有什么用
就是创建了就直接后面加{}开始写方法的内容 也没名字
匿名方法不会显式的声明返回值（就是没名称 也没名称前面 void/int 什么的）
但还是要匹配委托的返回类型 委托void就不能有返回值 委托int就必须要返回int
其他定义方法的东西 参数数量 参数类型和位置 修饰符 都要跟委托匹配
匿名方法能用空（）简化参数列表的条件 两个
1.委托里没带out的参数 2.匿名方法不用参数
书里提到了params参数 不太知道是啥
main方法有用这个来着 好像不太重要 讲的也是省略params关键字的事情 先略过了
匿名方法的内部变量在外面不能用 这个当然吧

lambda
期待已久的东西 似乎也不容易懂
目前没开始学习仅凭之前看过的代码来试着解释下lambda是来干嘛的吧
刚学了匿名方法 应该跟lambda类似 在声明时直接后面就开始写了比起之前的语法难看懂一些
但懂了之后应该是很简化语法的表达方式
之前看了好多次 一行代码各种运算符 把一般要十行左右的代码干的事给做了
应该会很高效 不过苦了没学过的人
 => 就用这个 根据之前委托写的各种类型 编译器能推断 所以可以写这么简洁
参数必须跟委托匹配 这是当然的 简洁不是乱写
表达式参数不一定需要包含类型 除非有ref和out（这时必须写）
如果只有一个参数 而且可以省去类型 那连括号都能省
如果没参数 必须写（）呵 有点意思
这就没了 感觉之前看的代码还要复杂点
找找代码 回看一下



==========20180725===========

事件
昨天睡前看了一下 没太看懂 好像是委托的应用
系统性学习走起吧
publisher-subscriber-enventhandler
发布者 订阅者 事件处理程序
看完概述 就差不多是委托 应该就是一般的触发机制
事件和事件处理程序同样保持一致的签名和返回类型 好像这时写作委托
关键字 event
事件不是类 是类或结构的成员 跟方法/属性一样
看下来好像也不是很难 不过图解教程这本书没练习 本身委托这些东西有些抽象理解了也不太会用 还是多做练习
含糊的看完了事件 感觉没用过还是太影响理解了
目前也没有遇到比较合适的场景 遇到了再回顾一下吧

接口
之前已经理解了 现在不细看了 目录里只有一两项不太清楚的
先说理解
接口就是约定好的一组函数成员 作用就是为了统一方便交换之类的 本质上就是个模板 所以不能实现
可以继承多个接口 只能派生接口
目录里两项不太清楚 实现具有重复成员的接口 as运算符
as应该强制转换差不多 不同的是 如果没有实现接口as表达式会返回null 强制转换会抛出异常
重复成员这个 书里讲的没看明白 就没写什么东西 最后成了什么样我也一脸懵逼
查了一下 书上讲的好像不太对 书上直接用类里面实现的成员 
网上查的是加个命名空间 interface1.method 和 interface2.method 这个样子
接口也就先到这 以后用的时候不熟再回顾

泛型
用<T>表示 感觉是一个非常好理解的概念 看看有啥骚操作吧
不是所有类都实现比大小 所以直接比大小的话会有编译错误
where子句
where TypeParam : constraint, constraint,...
用来对泛型进行约束
一共只有五种类型的约束
类名 class struct 接口名 new（）
两个名的意思是这个类或者接口的自己或子类才能用作类型实参
还能理解
class 任何引用类型 struct 任何值类型
new（）任何无参公共构造函数 （叫作 构造函数约束）
泛型方法
比一般方法多个<T>放参数（）前面
easy
调用泛型方法时就要提供类型实参
如果 public void MyMethod <T>(T myVal) { ....}
这种T一样 则调用时可省略为 MyMethod(myInt);
c#这种语法糖还挺合理挺舒服
泛型方法的限制 必须静态 第一个参数类型必须有this 这个this没明白
泛型委托 泛型结构 泛型接口
泛型接口要细讲一哈 接口可以有多个 泛型接口一样可以多个 而且同一个泛型接口用作不同类型算不同的
但如果用了两个同样类型的泛型接口就不行 等于只用了一个类型 但错写了一个
有点意思 没有想到 但合逻辑 没啥难理解的


==========20180727===========
可变性variance 分三种 协变convariance 逆变contravariance 不变invariance
感觉稍微要难一点了 跟基类派生类实例有关
看书有些复杂 
string》object 协变 （和谐）（用out   <out T>）
object》 string 逆变 （不正常）（<in T>）
???不变是啥
接口也能协变逆变 一样用 out in
不变就是光溜溜的 <T> 脑子瓦特啦非写个不变
感觉书都没细看懂 就大概懂个概念 后面的章节估计都是含糊看懂过去 之后再熟悉 也不是不可以

枚举器 和 迭代器
啥玩意啊
跟foreach有关 有道理诶
数组能用foreach是因为数组是可枚举类型 也就是还有不可枚举类型 emm
IEnumerator 接口 三个函数成员 Current MoveNext Reset 好理解
current只读 返回object 啥都ok
movenext 返回bool 新位置有效就true 无效就false 在第一次执行current之前必须调用次movenext
reset就是reset 重置
枚举器初始位置是 -1
IEnumerable 接口 就只有个GetEnumerator方法 没啥说的
泛型枚举器 也没啥特别的



==========20180811===========
现阶段面试难点主要是数据结构和简单的算法
视频讲的感觉有些慢 所以回归书本
算法和算法导论讲的挺好但数据结构感觉一笔带过
不能针对面试 这两本书应该是找到工作后持续学习的算法书
所以回归到《数据结构与算法分析-C语言描述》这本书
虽然也是美国人写的 但感觉跟国内大学教材差不多 纯干货 口感柴得一笔
但很符合我的需求 前面几章的内容我看了眼基本上是笔试上的知识点
所以先以这本书为主 先搞定工作
太基础的内容我基本上就跳过了 大O记号这些效率分析之类的 数学基础不熟再看

最大子序列和
买这本书时看到的最大子序列问题卡住了 没搞懂它对半分成两个子序列来分析有什么用
看了眼这个分析数学细节太细了 求和符号之类的 感觉没啥必要 继续看
三个for循环应该就是n3级别了 没看懂一堆求和符号在干嘛 也没有什么可合并的
分治之前算法星球视频有学 但从没具体实现过 卡住我的一点就是没看懂为啥能用分治
最大子序列和可能在三个地方出现 左半 右半 横跨
马海 我也知道啊 这么分是这样的啊
嗯 有点道理好吧 三个for循环是n3 左半的n3 和 整个的n3 效率不一样 所以分的很细的n3也就会很小 合起来的cn也不大
所以分治的nlogn有点道理好吧
这点想通了 继续
但是还是有问题啊 一共八个元素 分两份四个 然后就左n3 右n3 和带中间两个的n3 一比就出来了
分治只分到四个元素一组就不分了 这感觉分得不彻底枚举得也不彻底
国内教材这代码风格是真的难看
这个就分了一次的是nlogn 那分到底的似乎还会好一些
第四种算法
还是线性的 看了代码感觉这应该是直觉能分析到的 清爽
简而言之就是贡献为负的就不需要 一次循环就解决问题 牛逼

二分查找 跳过

最大公因数的欧几里得算法
互相除余
以前学到过 看一眼就过的算法 效率也挺爆炸 logn
主要是数学证明有意思

表 栈 队列
抽象数据类型 abstract data type ADT
最基本的三个数据结构
表 list 基本操作 PrintList MakeEmpty Find Insert Delete FindKth（返回某个位置上的元素） 附加操作 next previous之类的
基本上就是数组 找容易 插入删除麻烦（前后补位）

链表 linked list
每一个结构均含有 表元素 和 指向下一个结构的指针
内存中不必连续储存
最后一个单元的指针为null
代码细节
都挺直观的
指针错误我没细看
双链表和循环链表就很直观的能理解了
双链表就是还有一个指向之前单元的指针
循环链表就是最后一个指向第一个
还有双向循环链表 总之很直观
么得理解难度
应用难度一下就好陡 先略过了
栈
概念简单 应用略
队列就是一头进一头出
应用略

==========20180812===========
树
大部分操作平均logn 性能可以啊
二叉查找树
一棵树 n个节点 n-1条边
笔试遇到这个知识点  现在看来笔试的知识点都是挺浅的 学过都应该知道的那种
父亲儿子之类的概念都熟 高中学过
没儿子的节点叫 叶
高 是从叶算起 所以叶的高是0 一颗树的高等于根的高
深度 根的深度为0 就跟高反着的 从根算起
祖先 后裔 
n1不等于n2 祖先就成了真祖先 后裔就成了真后裔
这个真有啥必要吗
每个节点到自己有条长度0的路径
一种树的表示方法 向下箭头表示第一儿子 横向箭头表示兄弟 其他箭头不用画了 挺省事的
树的应用 经典操作系统的文件系统 dos unix vax/vms 最后这个没听过
看了这么多好像不是在讲二叉查找树 就是讲的一般的树
树的应用 文件系统
先序处理 好理解
后序处理 没理解怎么叶与叶之间是怎么处理的

二叉树
用来写表达式 感觉把表达式套上面一下就清楚多了
二叉查找树 左子树比节点小 右子树比节点大
节点左边的全部后裔都应该小于节点
严格
树的操作都好骚啊 难度上来了  有些泄气


==========20180818===========
迭代器
iterator
有点不太明白 现在我脑子不太好使
看不懂图解教程 换回入门经典继续看
入门经典这部分主要是 集合 部分
Collection
似乎平时用的array之类的都是属于集合类（Collection Class）
有各种已经标准化的接口
应该是比较通用化的功能吧




==========20181011===========
卧槽 我他妈九月份在干嘛啊 
八月底搬家 九月初收拾收拾整理整理 熟悉新家 各个地方弄一下
回过神来该学习已经一个月多了=。=
九月中旬买了只金毛 叫milky
后面注意力主要就在milky身上 训练 遛狗
昨天整理了下简历 投了几个
虽说简历真的没东西 但感觉行情确实不乐观
就那么几个在招人
智联和51上就找不到正经点的公司
从找工作开始 就只有一次是正经公司还笔试了 但当时真的啥都不熟悉 想着找找学习的方向
数据结构和算法的题完全懵逼 c#的题也不会 当时c#概念刚开学 只把最基础的学了
后面泛型 委托 接口这些 都没动过
其实现在也是之前好久学的一直没再动过了
老毛病

继续了不想之前的了
之前 C#方面看到集合 数据结构方面看到二叉树 C#这边还好跳过略过的东西不多 略过的都是细节具体代码之类的
数据结构这边 表 栈 队列 树 都是很浅显的基本概念 都是很简单的那种有关概念的选择题的水平
 概念方面都没有细看过 细节就更不用说了 全是面向笔试甚至是特简单笔试的学习
把C语言描述这本算法书看完 面试阶段应该完全没问题了
算法导论和橙皮算法那两本暂时当查询和补充来用 找到工作再开始细看
C#方面就把图解教程这本书看完
剩下的还有LINQ 异步 命名空间和程序集 异常 预处理指令 反射和特性
感觉剩得不多了 这些在之前的面试笔试都很少见过 只有一次被问到反射懵逼了
剩得不多就看完吧 假如剩得很多我就打算把之前的内容细看做课后题了
看书的重点还是数据结构和算法
C#甚至感觉已经够用了
主要是遇到懵逼的情况极少了
另外就是具体实现的部分
还是跟着视频课做demo吧 自己做模仿demo 感觉不是很有信心
很多功能连思路都没有 跟着做感觉上好像进度挺慢的
目前做的这个植物大战僵尸的玩意 还剩30节课 多得吓人
但自己做 卡进度应该会从头卡到尾 算下来还是很难受
跟视频课应该要好些 而且有素材 做的至少是看起来不错的成品
自己做哪有合适的素材啊
跟课至少进度稳定前进 自己也能一直学到东西
C/C++的Coursera课就不跟了 一个月两百多 学C也不是现在的事

养了狗是真的穷 现在也是负资产的人了 
本以为换了花呗开开心心 甚至有点想买新的东西继续换花呗.
没想到现在靠借呗周转 难受
早点工作挣点钱买东西=。=
不过养狗感觉减肥情况会好一些
今天一点15 有点困 先睡 明早健个身中午吃完饭开动
么得那么多嘻嘻哈哈了


==========20181012===========
之前堆栈队列树的内容都没细看 没做题 还是该细看一遍 题得做了
不过先把概念过一遍吧 至少看到这些名词知道是啥 大概适合啥 别一脸懵逼

今天看散列了 英文就叫hash 之前就听过哈希表之类的 应该是一个东西
能以O(1)平均时间执行 插入 删除 查找
但元素间任何排序信息的操作不会得到有效支持
所以 FindMin FindMax 以及以线性时间排序 都是散列不支持的



==========20181013===========
继续哈希表
感觉重要的就是哈希函数
就像一个洒水器 尽量把数据均匀的洒在存储空间上 这样 即使冲突了 冲突项也不会太多
合理的使用了存储空间 关键就是这个 怎么洒 也就是哈希函数
三个散列函数 前两个都看懂了 最后一个 没太懂 大概了解
第三个是多项式 有点像级数 应该是想填满储存空间吧 让哈希值尽量散开 有种撒大网的感觉

应对冲突的方法 有两种最简单
第一种 分离链接法
就是冲突的建个表 冲突了就把新的接到表上
找也是先找到表 然后在表里找
具体代码看不太明白 涉及到指针什么的 C还是不像C#那样简单

另一种叫开放定址法
就不解决冲突 冲突了就换另外的单元 知道找到空单元为止
后面的略了 简单的面试题水平点到为止

优先队列（堆） 题目叫这个
priority queue
优先队列和堆看题目好像是一个东西 百度了一下好像又不太一样
这句话让我有些懵逼 
堆（heap）是一种重要的数据结构，是实现优先队列（Priority Queues）首选的数据结构
em.......
堆是数据结构的话 那优先队列是什么东西呢
我以为我一直在学的就是数据结构 没想到还有一层新的概念
ADT 抽象数据类型 之前看了没在意
似乎 ADT是比数据结构更基础的
知乎里搜了搜 数据结构是ADT提供的规范的具体实现
大概明白了些 这种问题学着学着就清晰了

优先队列两个基本操作 Insert插入 DeleteMin删除最小者
DM的工作就是找出、返回和删除优先队列中的最小元素
插入等同于入队 DM就等同于出队
操作系统里会用到 大概是一堆任务里选最简单的来做这种思路吧 记得之前有个讲时间管理的视频提过
还有贪婪算法 也是之前听过的 大概是追求短期目标最优解的意思
优先队列的实现方法
第一种 很简单直接 在链表表头以O(1)执行插入操作 然后遍历整个链表删除最小元 O(N)
另一种是 让表保持排序状态 插入代价高昂O(N) 而DM代价低O(1)
相比之下 第一种好 因为 插入操作通常比Dm多
还有一种是用二叉查找树 两种操作都是平均O(logN)
不过如果反复删除左子树的节点 会损害树的平衡 最坏的情况 把左子树删空
右子树的元素最多是它应有的两倍 不过也是加个小常数的事
可以通过平衡树 把界变成最坏情况的界 防止出现坏的插入序列  这句话每台明白 主要之前树都不是特别仔细的看

二叉堆
是应该用的 一般堆这个词不加修饰就是指的二叉堆的实现

后面全是树 感觉可以回头了
后面的章节就是排序 进入算法部分了 还有个图论 貌似也不是数据结构
那么就开始细看了 做题 每个地方都要一个一个搞明白了
估计要个几天 然后进入算法部分 基本的排序这些
总共应该半个月吧 当然这只是数据结构与算法这些简答的部分 什么图论 红黑树 动态规划 就暂放着
先把简单的搞定

哎
十年前我有机会学这些东西的
学了之后我觉得应该不会像现在这样窘迫了吧

==========20181030===========
又换书了 大话数据结构 这本书
看着就挺白话的 入门够了
走着

int string 这些算是数据类型 跟之前的基础部分联系起来
抽象数据类型ADT 是一套数学模型 定义仅取决于它的逻辑特性 跟其在计算机内部如何表示和实现无关
emmm.....所以数据结构是计算机学习中的基础 有点感觉了
不过这书过于简单直白了 感觉想是科普读物 干货也有 不过
第二章算法跳过 讲的是算法的比较 牛逼的算法是什么样的 时间复杂度空间复杂度 大O记号之类的

第三章链表
开头的比喻挺有意思 幼儿园小朋友排队 每个小朋友记住前面是谁后面是谁就行了 形成习惯后 谁没有到位直接能报告出来
还是双链表
链表的描述和一些特性就跳过了

数组长度 与 线性表长度 的区别
我还以为线性表的单元是数组 好像不是
数组的长度是存放线性表的存储空间的长度
这话....
线性表占用的存储空间的长度吗？ 线性表不一定会用满
任何情况下线性表的长度小于等于数组的长度
这理解应该没问题

线性表的起始是1 数组的起始当然是0...
......为啥呀 为啥不统一啊
我以为计算机的世界里起始都是0
地址计算方法 感觉不太对
之前我记得学的是链表的元素是散列得储存在内存里 链表的这个单元里包含了指向下一个单元的地址和这个单元包含的数据
一个个的地址是一路指下去的 散列的
这里写的是线性一路排下去的
这里好像单指了顺序储存结构 线性表和链表可能还有差异
不合理的地方马上来了 插入和删除都涉及操作位置之后的所有元素要挪屁股
存取一时爽 插删火葬场
那我的理解没有问题 这里讲的是一字往后排的顺序结构

链式存储结构
链式就是爬的时候就是O(n) 插删方便

静态链表 跳过了 是没有指针类型的语言里用数组建立链表
算了还是不跳过了 感觉还好理解
数组的每一个下标都对应一个data 和 一个cur
data存放数据元素 ok
游标cur相当于单链表中的next指针 存放该元素的后继在数组中的下标
插入删除等操作都还挺好理解的


==========20181031===========
栈
前面一些介绍和特性都跳过
队列（queue）是只允许一段进行插入 另一端进行删除的线性表
先进先出
为什么栈要共用空间没太懂
adt都是概念 具体代码没见到 感觉用了才能更熟悉

字符串
感觉不知道为啥字符串算adt
字符串主要操作都是针对子串的
匹配 删除 之类的
感觉就是个字符的数组呀
匹配算法 应该是专门用来找字符串的
有个叫kvm的算法 没细看

翻了下unity入门到精通
ugui这章 感觉我之前学的都学完了
我以为ugui还有好大一部分 没想到基本上内容都学完了
还是要多练 不练感觉还是光知道概念
就是一种一说都知道 该做的时候又懵逼

==========20181101===========
补充两栈共享空间
看明白了之前觉得有点难跳过了
一点不难
就是拿一个数组用作两个栈的空间
头这边一个栈底 尾那边一个栈底
然后首尾加元素时都向中间延伸
栈什么时候满这些就看两个栈加起来慢不慢
挺简单的

栈的应用 四则运算

==========20181104===========
字符串匹配
上次略过了 这次好好看看
匹配应该是字符串最重要的操作
朴素匹配的办法就是一个一个比
最差的情况是每次匹配都是最后一个字符不对
而计算机里经常是0和1 所以朴素匹配的方法效率很低

==========20181105===========
明天有个面试 hr给我吹的加拿大海归主程要求有些严 害怕我通不过
我表示给个机会
害怕让我来害怕 要求严我也一时没法补完
今天打算看完c# 异步 异常 反射
linq暂放

异步
进程和线程
进程是构成运行程序的资源的集合 线程代表真正执行的程序
不是很懂
目前接触到的都是一个程序使用一个线程
但这种简单的模型并不实用
异步就是让程序不需要按照编写时的顺序严格执行
不让程序等待响应 而是在等待的同时执行其他任务 然后回复到达后再执行原来的任务
大概是说跟服务器请求数据这种事 传数据挺耗时间的 程序不应该停在这等
异步先略过 看了一下 不是两下解决的事情 而且目前没有需求

命名空间和程序集
之前浅略的了解了一下 目前也够用 暂略

异常
感觉是无比有用的部分
找bug改bug可能是职业生涯的永恒的主题 程序员职业生涯的意义之一
try catch finally
还没细看书 大概了解
先执行try 若里面有问题
就不执行try 改执行catch
最后不管有没有问题都要执行 finally
异常类
有系统异常 预定义的 估计也是致命的
还有应用程序定义的异常 非致命的 自定义的
catch子句有三种形式 
第一种不带参数 就是匹配try中任何类型的异常
第二种 带个异常类型 匹配该类型的....
第三种 带异常类型和异常变量 就是匹配具体异常变量的
对了 匹配异常都是指定类及派生

第三种我好像理解错了 带的异常变量是clr创建的异常对象的应用 
也就是说可以在catch里访问这个异常变量 可以获得更多引起的变量的详细信息
有意思
catch子句可以用多个 那么就有哪个放前面哪个放后面的问题
那当然是最明确的最特殊的最特别的放第一个
最普遍的放最后
比如一般catch句 就是不带参数的 那肯定该放最后一个 要不然第一个触发会挡掉后面的更细的catch子句
即使catch里有错误 finally都会执行
突然想起之前有谁提到trycatch的滥用 现在一想这不应该滥用吗
滥用这个不是应该的吗
异常处理流程简略看了一下 finally之后在try块后面继续执行
throw 可以引发异常 具体也粗略看了下 略了

反射
重头戏来了
有关程序及其类型的数据叫 元数据 metadata
查看元数据的行为叫 反射 reflection
type类
貌似是类型的类型
type类包含类型的特性 使用这个类的对象能获取程序使用的类型的信息
平常经常见的方法 GetType()

特性
大概讲了十几页 今天不看了 肯定是脑壳疼的那种东西

==========20181106===========
树
基本的概念就略了 不熟的记一下
结点拥有的子树树为节点的度（degree）
根为第一层 最大层次成为树的深度（depth）或 高度

树的存储结构
找父亲法
就是带指父亲在哪的指示器
data+parent（指针域）
还可以加 长子域 右兄弟域
像找父亲这个方法
找父亲就很简单 O（1） 但找孩子就难得一比
存储结构是非常灵活的 应该根据要用的方法是否方便来设计
找孩子法
孩子兄弟法
各有利弊 略过

二叉树
同样基本概念略 不熟的记
特殊二叉树
斜树 就是只有左子树 或者 只有右子树
满二叉树 就是都有 完美

完美二叉树 有点特殊 跟满二叉树有区别
对二叉树编号 二叉树中结点的位置跟满二叉树完全相同 则为完美二叉树
完美二叉树的编号不能空档 到12的树不能缺10 可以没有12

二叉树的性质
1.第i层上最多有2的i-1次方个结点 （i >= 1）

2.深度为k的二叉树 最多有 2的k次方 - 1 个结点 （k >= 1）
注意这个k跟上面的i 次方不一样

3.任何一个二叉树 叶子数为n0 度为2的结点数为n2
n0 = n2 + 1

还有几个性质 一共五个 记事本打公式不方便 先放放

二叉树的存储结构
一维数组
一般的树用顺序储存比较困难 但二叉树可以
就是按二叉树编号来的
但由于斜树一般k个结点却要用2的k次方-1个储存单元空间 所以顺序储存一般只用于完全二叉树
二叉链表
一个数据域两个指针域（左和右）
没啥好说的 就挺直观

二叉树遍历
前序遍历
先根节点然后前序遍历左子树 然后 前序遍历右子树
总的来说就是 从 根开始 能左就左 不能就右 O了

中序遍历
先中序遍历左子树 然后访问根节点 然后中序遍历右子树

后序遍历
先从左到右先叶子后结点的方式遍历访问左右子树 最后根节点

前中还好 后序有些困难 但都有递归的思想在里面

后序这个先从左边的叶子开始访问右子树再结点 然后再找右子树的叶子 继续这个过程

噢噢噢噢噢噢 突然顿悟
其实就是当成个三角形
前序就是根-左-右
中序就是左-根-右
后序就是左-右-根
然后记得要用递归就好

还有个层序遍历 很粗暴 每一层都是从左到右




==========20181107===========
二叉树的建立
代码看不懂 感觉C语言里面符号用的好多
过段时间再学C吧
感觉C/C++ 有力量的感觉

线索二叉树原理
不知道是个什么东西


==========20181112===========
今天终于上班了 上班看代码 春熙路上的lcd的网络电话demo
其实内容真的就委托和事件 主要是代码太杂 工程代码本来就跟教程里的不是一个复杂度
一堆代码里 一些是自动生成的所以每次都是几乎一样的 一些是很底层的 还有一些是依赖外部库的 我都看不到 就只能看到函数表面

回家再温习一遍事件和委托


==========20181225===========
日记
在第一家公司实习一个月后我就换了家公司 走了以后对第一家公司的诸多不满才想明显地表达出来 加上我性格上还不够成熟 
所以这次离职不是很愉快 我自己该做好交接的 但心态浮躁 周五面试 周一就让我去新公司上班 老公司让去交接
不是很想去 我还不够成熟加上对老公司的不满 不想进入尴尬的境地 结果就是就没回老公司交接
我也找了诸多理由 例如毕竟是实习生 之前以为是提前一天通知就可以不去公司了 后来查了一手发现是三个工作日才可以离职
老员工和老板我都不太看得上 还有新公司的对比 当然主要还是我的问题 其实再差的公司 自己离职也该把善后工作做好
有理有面 diss老公司的时候才完全不觉得愧疚
现在倒也完全不愧疚就是了

新公司入职后其实那股满眼美好的劲儿归于平静
面试的时候sumi告诉我的是下周进度紧张 所以周一周三加班
我说ok 很正常
没想到是周一周三固定加班
同样是大小周 第一周还赶上大周
现在第二周 但又赶上元旦调休 又是个大周
不过呢 元旦三天休息还不错就是了
问题还有呢 现在还没签合同 再不签合同我就双倍工资了

但是
好的一面真的也不少了
首先是目前来看 新公司做的游戏 至少品味好些
带我的哥们 家威 比之前公司的刘哥好太多了
耐心 没有逼迫 以非常平等的姿态交流
我反而显得没那么低姿态
第二 我以为这段时间公司都节奏慢 听家威说 其实只有我们两个人节奏非常慢 其他人的进度都很赶
我第一第二天好做了点事 翻译啊 加小功能这些
第三天第四天 在看几乎纯数学的 四元数
第五天开始接sdk 进度之缓慢
今天第二周周二了 我终于把mimoSDK接完了 今天倒也把vivoSDK接得差不多了
明天应该两下就搞定了
就算是固定加班的周一周三 我依然非常得闲
非常缓慢的接sdk
Android的坑是真尼玛多

最近的学习情况比较糟糕
换公司那个周末心态完全放开
然后现在已经第二周了
晚上都没怎么看过书 

诶？ 查了下记录 我以为上周比较少 七个番茄钟
上上周更少 六个番茄钟
再上一周九个番茄钟
em........
学习堪忧
合每周平均学习时间 3小时
每天平均25分钟
（掌嘴）

先努力达到日平均两个小时的学习水平吧
比较2019年的目标是 合格的CS本科毕业水平
意味着四门基础课要搞定 加上C# U3D 争取C++和图形学

今天还有半个小时 开整

希尔排序
思路就是 插入排序交换效率低 只能相邻交换 希尔就跨大步子 做间隔h的有序子序列
然而这种奇葩的排序 现在都不能完全理解透彻它的性能
无法准确判断其性能特征
奇葩到一定地步了
不过比插入强的理由理解了 我觉得应该就掌握到希尔的精髓了
希尔排序最坏情况也是N的二分之三次方 那是比插入的N平方吊
但希尔还不是最屌的 还有更吊的
希尔通常可以用在中等规模上
小规模那就N平方都ok
大规模希尔可能有些不够看
书上这么写的 要解决一个排序又没有系统排序函数可用 就可以用希尔
嗯 这么说来是个优秀的备胎

归并排序
难的来了 而且也是好像最常用的快排的前置
牛逼的是任何规模 NlogN的水平
空间复杂度是N 我觉得也挺好的 但好像对空间复杂度的追求都是1
所以归并追求的都是原地归并 但已有的实现非常复杂 特别是跟空间复杂度N的方法相比

原地归并的抽象方法
先把两个有序子序列放到同一个数组里
[lo---mid] +  [mid+1---hi] 这样子
打个比方
把这两个数组 当做两个传送带 异星工厂里那种
两个传送带成V字型 交点是个比较器
谁小谁先上最终数组
因为两数组是有序的 所以都是两数组各自最小的数来相比
先if处理像是一个数组没数了这种情况 就一个一个上另一个数组的剩下的数
然后if 比较 谁小 谁上
理解到位看程序写程序顺畅得一笔
这个部分就能保证归并算法能正确的排序
归并就用V字传送带一直二分所有元素 然后汇总
诶？不是说原地归并吗 还是要用一个跟原无序数组同样大小的辅助数组
sort[a , 0, a.length-1] = sort[a, lo, mid]  + sort[a, mid+1, hi] + merge[a, lo, mid, hi]
递归二分 然后归并 

妈的 从来没觉得递归 这么他妈爽
十二点半了 今天就到这里 
学习了还是很满足的一天

==========20181227===========
归并排序里
对小规模子数组使用插入排序甚至还会提升效率10%-15%
这点还真有点意外
插入排序对小规模数组是挺快的 这个可以理解
而归并对小规模数组的调用反而不少
也就是说
归并对规模大规模小的数组 其实都基本上是一个效率
而插入排序对于大规模数组 一个元素的找位置是数组越大也就越慢 这个很好理解
所以各取其优点得到更好的效率

但这种事吧 感觉可遇不可求 能这样操作当然是好事
那得能做到这种骚操作

然而还有骚操作
加一个判断 a[mid] <= a[mid+1]
也就是说 这边的最大比那边的最小还小
那两有序数组直接接上就完美合并了
这个判断不影响递归调用 对效率的负作用微乎其微 
对效率可能的积极作用就很大了 当然这是对一个操作来说

还有骚操作是什么不将元素复制到辅助数组
这个一眼没看懂而且书上也没细写 当做一道习题了
就略过吧

我倒是真没想到这些基础的算法还有提升效率的骚操作 有点意思

自底向上的归并排序
意思很简单 就直接把每一个元素看成长度为1的数组 直接开始合并
没有递归 省去了从上到下的过程

==========20181228===========
快排
应用最广 实现简单 原地排序 nlgn
好像挺牛逼
缺点非常脆弱....使用要非常小心
啥意思

快排跟归并是互补的
切分（partition）成两半 
这两部分有序 合起来就整体有序



==========20181230===========
算法题我还没刷起来 这个很重要 尽快吧 有挑战就有成就感 学的东西也能巩固
今天放假第一天 八九点打完球回来觉得又困又冷就睡了一会 刚刚洗个澡终于没那么冷了
现在十一点 觉得没啥想玩的 就开始看书了 感觉这样很好 我又变强了
有学习的节奏 变强就是时间问题

前天看快排还是没懂 看图解觉得很牛逼 咋两下就排好了 那天晚上看书没看多久 有些飘
今天好好看看

代码里首先有什么 消除对输入的依赖 切分也暂时不知道是咋回事
sort函数还是递归调用 这sort里连交换也没 按理说这个再怎么递归 也没实际进行排序的操作
瞄了一眼后面的切分函数 里面有交换

看书有点懵 就看了知识星球
一下就明白这个算法咋排序的了
一个打乱的数组 随便找个下表当枢纽元
然后从数组的头开始 两个下标 i和j
先说整个数组在排序过程中的结构
【小于枢纽元的部分】【大于枢纽元的部分】【剩余的未排序部分】
然后是枢纽元 这个其实放头和放尾巴上都一样 无所谓
重点是i和j的作用
i实际上代表着大于和小于这两部分的分界点
j代表下一个未处理的元素
所以逻辑就很清晰了

a[j] 大于 枢纽元  j++ //处理下一个元素
      小于 枢纽元  a[i]就跟a[j]交换 i++ j++ //处理的这个元素小于枢纽元 把它放到【小于枢纽元的部分】 

//i代表的边界拓展了 j也处理下一个元素
然后处理完之后把枢纽元放到大于和小于部分之间就ok

还以为很麻烦 但其实挺简单的
接下来就是改进方法以及对快排不稳定的处理吧
今天就到这

==========20190109===========
今天开始重新学习线性代数 大学的时候有些过于水了
这种基础课今后又有用的必要 所以必须得补
买的书第一章讲线性代数中的线性方程组
完全不知道在讲什么 翻略一遍决定从第二章开始 矩阵代数
熟悉一些 但感觉第一章的内容在讲为什么有线代 之后再重新学习吧
开始
.....
瞬间懵逼了 学线代时的那种懵逼 所以最后只会个乘法

还是从第一章开始吧
线性方程组是线代的核心 等价向量方程等价矩阵方程
矩阵的意义是啥我还没明白


==========20190113===========
继续 算法 这本书
最近买了好多书 图形学 线代 还有那种程序员生涯长期阅读的书 什么 代码大全 代码整洁之道 编程珠玑
这三本应该算编程方法论的书 买来看了翻了两页
好像完全没代码 全是文字 干货密度稍低 但全是教该怎么写代码 该怎么设计之类的

先数数自从打算做程序员来 买了多少本书
我基本上都放电脑桌旁边的椅子上了
C#的 大概三四本 C++prime
算法应该有三本 网络 tcp/ip 操作系统 各一本
unity应该有三四本
图形学三本
数学方面两三本

一共有差不多二十本了
一本都没有完全看完
进度最多的应该是C#的入门书
算三本吧 都是80%的完成度

虽然这些书都不是那种必须看完这本才能看下一本的
但是 我还是感觉我书看少了 买书是想到立马就买
每周看书的时间说实话还很不满意 上周我归咎于感冒导致的心情原因 一共三四个小时吧
当然也有周一周三加班另外加上小周的周末只有一天这个因素
还有就是 上周周末完全没看书 原因应该是想到这周一的任务完全不知道怎么搞 心里有些畏惧
没想到的是 周一一天两下就做完了 周二也就修补了一下 那边验收也没有动静
所以教训是
加班也好 小周周末短也好 接下来的任务完全不知道怎么做也好
都尽量不要沉浸于那种压抑 那种不知所措的害怕 之中
要有泰上压顶而泰然处之的心态
这个阶段 刚开始 我还是个新人
不会有那种天塌下来让我顶的情况
想想也是 心态爆炸轮不上我的
还是不够成熟 还是浮躁
看书时间受这些影响 尽快达到看书练习获得成就感的那种正向循环的状态

还有个问题是 现在书这么多 貌似最近已经不需要再买什么书了
该优先看什么 
这是很重要的问题
一方面我基础极其薄弱 四门基础课 算法算走了一半有没有都不好说 算刚入门吧
其他三门课完全没有开始
C#也算刚完成初级阶段 而且最后的那些部分还不是很完整很牢固
反射完全不懂 委托事件还很不熟
还有异步和LINQ 几乎没看吧
这个初级算80分的初级吧
数学的那部分更算基础 3D数学 离散数学 线代
该补还要补
C++看来也是今后非常核心的内容
图形学又什么时候开始呢
unity的内容也一抹多啊 虽然感觉这些业务没有刚刚说的那些计算机基础 数学基础 语言那么长效持久
但感觉跟升职加薪关系非常大
我现在的生活状态又非常需要升职加薪解决很多问题
还是很纠结

直觉判断是
先优先算法吧 毕竟是最重要的基础 同时也是面试的核心
再来是C#和unity 算业务能力吧
算法看完了就开始剩下三门基础课吧 网络 操作系统 组成原理
然后是数学基础
做完之后再开始图形学吧 比较图形学程序员感觉是个高端工种
需要转职的那种 所以先把初级职业做好了再考虑转职的事情

那继续算法
优先队列
是一种adt 基本操作就两个 删除最大元素和插入元素
所以优先队列跟队列不是改进优化的关系 有本质的不同
队列跟栈是差不多的
优先队列一定会对所含元素进行排序
基本上是用二叉堆进行实现的
排序算法使用的堆排序
感觉应该不是删除最大元素 而是pop最大元素
删除感觉根本不拿这个最大元素直接删掉了


==========20190114===========
昨天周日没看多少书 一共一个小时
但今天好像还很不错 周一固定加班到九点 十点钟我已经坐好开始看书了
心情不错 就很棒
优先队列实现的起点是四种基本数据结构
有序数组或无序数组或链表
无序数组是用选择排序的方法 有序数组是用插入排序的方法 都没啥值得看的
链表还是用很普通的遍历来找最大元素 没意思

使用无序序列是解决这问题的惰性方法 仅在必要的时候采取行动（找最大元素）
使用有序序列是 积极方法啊 尽可能地未雨绸缪 （插入元素时就保持列表有序）

而使用堆来实现 都是logN级别的表现

堆貌似就是二叉堆
堆有序 = 一颗二叉树的每个结点都大于等于它的两个子结点
所以在二叉堆 从任意结点向上都能得到 一列非递减元素
向下 = 一列非递增元素
所以 根结点事整个堆有序的二叉树中最大的元素

二叉堆是一组能用堆有序的完全二叉树排序的元素 并在数组中按照层级储存
完全二叉树就是要缺只能从右子树开始缺

重点来了 堆的有序状态因为某个结点变得比它的父结点更大而打破
修复办法是 将这个结点向上与父结点交换位置 直到它不再比父结点大为止

感觉很简单啊 就跟冒泡一样
某个结点变小的情况 是通过交换它与它的两个子结点中较大者直到位置合适

严密的黑社会组织.............

==========20190115===========
六点下班 八点十一坐在电脑面前开始看书
今天看个两个小时左右 十点钟结束
还有两个小时能玩玩
感觉状态好得一比
充分抓紧时间心情就会不错 学习也学了
耍也有时间耍
而不是东摸摸西摸摸 然后把时间浪费掉
在紧张 不安 慌乱中 耍过去 心里都不放松
不好

看书
今天进入第三章 查找 感觉会比排序简单
不知道我的感觉有没有问题
这书一共也就五章 第四章图 感觉会很难
第五章字符串 这就搞不清楚了 听说是很难
但是为什么会难呢 又为什么字符串能成一章而且是全书最后一章
感觉还是最难的
看起走了

符号表
没听说过 应用里第一个就是字典 那其实感觉就是字典
符号表的主要目的就是 将键值与值联系起来
方便获取 高效的查找和插入

表不允许重复的键 很好理解
不允许有空键和空值 没啥太多为什么
删除操作有延时删除和即时删除
延时删除是先把值置为空 之后删去值为空的键
即时删除是立即从表中删除指定的键
这书里的put（）方法有句防御性代码
如果值为空 就删除键
表还是挺注意保持完整性的
迭代功能 跟C#里的迭代器有关 没啥细说的
键的等价性 其实就是可比性 跟查找有关
这东西得可以equals（） 这么说就明白了
要不然怎么找 那我刚刚说错了 不叫可比性
应该叫可等性 可比性应该有大小的关系
可等性就是能不能确认两个东西是一样的

有序符号表
典型的程序里 键都是有可比性的 所以就实现键的有序来更好的实现put（）和get（）
有序的话
下面的操作就好实现了

最大键最小键 没啥说的

向下取整和向上取整 得仔细读一下 应该不是我理解的那个意思
向下取整 找出小于等于该键的最大键
还好 就是有点像raycast 从某一点向某个方向出发 撞到的第一个家伙
那这方法的名字就有问题 取毛的整呢 方法只是有点像取整而已 
再说 整这个定义在这里没意义 也没定义过
向上撞向下撞都更贴切一点
英文叫 ceiling和floor 跟取整也没啥关系 翻译没过脑子
跟数学上的取整可能是英汉的关系
但在这里 这个翻译太不好了
搞得我都写了这么一大堆在说这个芝麻事

排名和选择
排名好理解 还是键值的事
选择的意思是选排名为k的键
所以还是翻译有问题

范围查找
给定的方位内有多少键 是哪些
这问题都是自然而然的

找不到键值要抛异常
都是很正常的功能 没啥骚操作

提到成本模型 没懂是个啥意思
好像是统计比较的次数
不进行比较或者比较极少就会统计数组的访问次数
 这个FrequencyCounter 没啥特别的

无序链表中的顺序查找
开始看不明白
其实就是顺着链表一个一个摸
但效率一看就太低了
摸到了就返回值 值不对还要改值
不是很懂为啥传了键又传了值
估计是为了统一摸不到的情况
摸不到就加结点贴上去
摸到就是命中情况 摸不到是未命中情况
命中情况都指不定要摸到链表的哪个位置
摸不到就得把链表摸完一遍
链表的结点一多 未命中情况就效率爆炸 加结点操作都是线性时间
命中情况效率也不高
向空表插入N个不同的键和值需要 二分之N平方次比较
这效率有点差
书上说分析查找比分析排序难 看来是的

有序数组的二分查找
这个。。。。好像不需要看什么
扫一遍看有没有骚东西吧
效率N个键的有序数组 最多需要lgN+1次比较
虽然查找效率高 但这是有序数组
一般情况还要加上排序时间
另外是插入操作效率有些低
大小为N的有序数组中插入一个键需要访问2N次数组
空表插入N个元素需要访问N平方次数组

二叉查找树
概念都熟悉
牛逼的是查找和插入都是同样的效率
爬树 然后到地方就完事了
影响效率的是树的形状
最坏一条线
平均效率为~2lnN
其他操作都不难
最麻烦的是删除
删除一个子结点的结点很简单
两个子结点怎么办呢
删了然后接后续结点
后续结点就是右子树中的最小结点
不知道对不对 今天看书的注意力不太够了

已经打开了P站
12:41分
算下来今天净看书还是有两个小时多一点
关键是今天书也看了 心情还不错
最近打游戏的热情几乎没了
这个月psn会免 重力异想世界2还不错
周末打了打 动作挺流畅的
能玩但估计没精力通
之后 只狼肯定要玩 但打算买steam版
比较操作熟悉加上有修改器
过几天还有皇牌空战 也买steam版
总之能steam就steam
独占才买ps4



==========20190117===========
今天继续看上次没看完的二叉查找树的删除
这个删除还是个递归 不是简单的一次性操作
先保存指向即将被删除的结点的链接 保存为t
然后找右子树中的最小结点 也就是在右子树中一直找左子树 直到左子树为空
这个结点就是拿来接上被删除结点的后续结点
然后把t接上
书上说了个 在递归调用后更新链接和结点计数器 没懂啥意思

范围查找
在二叉查找树里的轨迹有点像左右横跳

二叉查找树就粗略的结束了 
还行 算法基本上都理解了 可能漏了些细节
想起来最近真的看算法书 写代码写得太少了

算法书今天有点看不动 他妈的后面都开始双结点了
今天就不看算法了 看看C++
目前还是在看最基础的那部分嘛 应该很快 而且很简单


==========20190128===========


==========20190209===========
今天看C++
之前看网上的C++教程 内容还是很硬核但是更硬核的内容要收费
这就很难受了 也不知道是不是很权威
所以又开始看C++ primer
目前看的还都是很基础的 但C++我又不敢随便跳过
数据类型这里还是可以细看一下 毕竟之前就C#没细看 数据类型的细节完全没概念
平时用就只用些 int float bool string 就这么多了

bit 位 内存单元 
这种细节我之前就没有学 感觉还是很重要
short 至少 16位
int至少跟short一样长
long至少32位 且 至少与int一样长
long long 至少 64位 至少与long一样长
字节 byte 通常指 8位内存单元 而在C++里对字节的定义于此不同
C++字节由至少能容纳实现基本字符集的·相邻位组成
这句话听不懂 而我看书也不应该抄这种东西=。=
总之C++里字节至少8位 且通常为8位
不同的系统这些数据类型的位数是不一样的
所以C++程序换环境（包括一个系统使用不同的编译器）时 可能会引发问题
C++不就是容易出事吗...
short 是 short int 的 简称
long 是 long int 的简称
这些都带符号
大括号初始化器....什么东西 不明白
学C#的感觉是顺利成章的 很顺而且自动地很系统
C++感觉就很散 这也可以 那也可以 有些古怪
unsigned关键字指无符号的 0~上限
unsigned 本身指 unsigned int
C++ 溢出不出错
那么问题来了 C#溢出会出错吗 我感觉也不会出错 查一哈
没查到 试了一下 也不会 这种值的溢出是不会的
栈溢出 内存溢出 都会出事
这种值越界应该不算什么很严重的事 所以编译器什么的都不会报错

开始讲进制了 之前我都跳过的部分 而且我甚至不知道语言入门书里会讲进制
直接写例子吧 
int i = 42；
int j = 0x42;
int k = 042;
结果是
42 66 34

i就是十进制的没啥说的
j是十六进制 0x或者 0X放数字前面表示是十六进制
k是八进制 第一位是0且后面的位上的数字都是1~7 （也就是符合八进制）就表示八进制
好奇在C#里试了一下 想都想得到0x这个肯定ok 
而八进制这个就不行 C#会无视掉前面这个0 还是当十进制处理
那么问题来了 C#里的八进制怎么表示呢
诶 这就有意思了 
C#他妈不支持八进制 至少是不像C++这样支持
C#的八进制要手动转 而且是toint里转 有个重载 要写个8当参数
其实就是基本上不支持八进制 只是给了个表示的方法

==========20190211===========
cout还可以用从控制符指示cout以什么格式来显示整数
dec hex oct 分别表示 十进制 十六进制 八进制

int i = 42;
int j = 42;
int k = 42;
(cout << dec;)
cout << i << endl;
cout << hex;
cout << j << endl;
cout << oct;
cout << k << endl;
结果
42
2a
52

问题来了 整型变量的类型告诉了编译器 那么赋值的常量的类型怎么知道呢
答案是 除非整数后面有后缀表示类型 否则都按照int来处理
如l或L表示long u或U表示unsigned int
ul（不分大小写 但方便辨别 应用uL或UL）表示unsigned long
ll或LL 表示 long long
uLL（同样不分大小写 不一一全写）unsigned long long

char实质上也是一种整型 并且比short还小 存的是字符的编码
cin和cout会进行编码和解码的部分 所以

bool型 可转为int true为1 false为0
所有数字值或指针值都能隐式转换成bool
零为false 非零为true

const 限定符
先说我自己的理解 跟java里面的final差不多
声明就得给值 然后就不能改了
而书的内容也只有半页多 而且主要在讲用const比#define要好
跟我的理解没冲突

浮点数
这东西很多年前用金山游侠就知道 但至今不知道细节
将大值分成两部分 一部分表示值 另一部分对值进行放大或缩小
这个地方我看书有点懵逼了 在b站上找了公开课的视频看了眼
好像也没那么难
如 34.1245 和 34124.5 两个数 除小数点位置不一样 其他都一样
34.1245  = 0.341245 * 100
34124.5 = 0.341245 * 10000
所以第一个放值的地方 要把实际值化为纯小数 然后另一部分就是缩放因子
说白了就是科学计数法
写浮点数的两个方法
第一个就是正常写 xx.xx
第二种就是科学计数法 5.98E24 = 0.598 * 10^25
可以用e也可以用E 但这种方法数字中不能有空格


==========20190213===========
K.N.King 的C语言书到了
我直接跳过之前的部分 开始看指针
指针应该是C语言最重要的部分 C语言的核心

指针就是指向内存地址的值
指针变量就是储存地址的变量
指针=地址
指针变量需要在变量名字前放*号
int *p
说明p是指向int类型对象的指针变量
int i,j , a[10], *p;
指针可以跟其他变量一起声明
i j 是普通整数型 a[10]是整型数组 p是指向整型对象的指针
C语言要求每个指针变量只能指向一种特定类型（引用类型）的对象
指针也可以指向另一个指针

取地址运算符 和 间接寻址运算符
&取址 *间接寻址
如果x是变量 &x就是x在内存中的地址 也就相当于指向x的指针
如果p是指针 *p就是当前指向的对象

然而把间接寻址符用于未初始化的指针变量会报错 很好理解
给*p赋值又极其危险 甚至导致系统崩溃
=。= 有点吓人 C#和vs的那种环境好像是太舒适了
指针赋值这个好像有点意思
因为相当于一个箭头 所以改一个另一个指向的值也会跟着变

任意数量的指针变量都可以指向同一个对象

 p = q
*p = *q
要注意区分
第一个是指针赋值 意思是吧q指针赋给p指针 也就一样了
而第二个是把q指针指向的值赋给p指针指向的值


==========20190223===========
春节前后到最近状态都很一般 看书很少 感觉不想做事 milky也遛得少 不好
家威离职了 然而我就没事做了 两周了 一共做了两天的事 其实只有一天 另一天卡bug
这bug我还无能为力 而且也不是我的锅 在vivo手机上一跑就行 其实也不算bug
接vivo的sdk只能在vivo上用 也不算什么稀奇的事
这里我突然想到 我的6p大概是14年15年之间拿到的 幺爸送我的
现在用了五六年了 然而16g的内存非常难用 app不敢多下
至今保留最常用的几个 其他的都得删掉 要用的时候再下
非常不爽
之前也想到过几次这个问题 接下来我要换什么手机
其实这个事还挺重要的 毕竟手机现在是人生活的一个器官了
以上一台机子和再之前的机子来看
我的手机至少也要用三四年
so 还是得好好挑一挑
然而我很少关注手机
其实要求就一个 有耳机孔
因为算是我的习惯 我一天到晚基本上都带着耳机
但其实之前用蓝牙运动耳机也还行 但还是有两个缺点不太能忍
1是带着不太舒服 2是毕竟是电池 不够用
而我又是带一天那种 所以 还是得要耳机孔
安卓还是苹果 这个其实之前我还铁了心想要苹果 最近真的安卓完全ok
因为苹果1是没了耳机孔
2是 其实这几年用苹果 并没有感受到那种只有苹果有的优点
而且苹果的配套软件一个比一个傻逼 iTunes烂的一笔
照片也是 连自己建文件夹都不行 多选也是噩梦
色图多了真的很难找东西删东西
想传到电脑上也是 跟求爹一样小心翼翼才可以 还不敢动什么 很容易爹不乐意了
还他妈很贵
查了下 基本上没多少手机带耳机孔
华为mate20贵得一笔
魅族16th好像价格还可以
想了会 还是妥协吧
充电的地方常备转接口

补一下快排
之前快排没看透彻


==========20190225===========
之前对快排的理解有问题
切分函数那里倒是还没啥问题
选个key值 小的放前面 大的放后面
但当时我没理解为啥前面和后面能做到有序
排序这个操作在哪里实现的我一直没注意到
其实这个切分过后会对前面和后面这两部分再进行快排
也就是说这其实是个递归 所以说我只看到了第一次切分
下面的递归层我都没看到
所以上次看得是个啥啊 看个皮毛就跳过了

书上说什么归并和快排是互补的
这个互补是真的不恰当
意思应该是快排是因为左边小右边大 
左右都有序的话直接接上就全部有序
归并是分成很小的小部分然后在合的时候排序
讲快排的时候书上也是分层次讲的
所以分成两部分 两部分的排序一句话就带过了
具体的排序后面才展开
上次看书不太细致也有这个原因吧

通过递归调用切分来排序
也就是说最小的部分应该是三个数
小 key 大
所以说可以小到一定规模该用插入来排
分太细是有些浪费性能
照书上的写好 发现没排好...
书上说有些细节可能导致错误

不对我抄错了
我也自己删了重写一遍
还不是很牢固 还需要看几眼
不过整个过程都ok了


==========20190226===========
平衡二叉树
二分查找树的升级版 似乎保证了结点的平衡
2-3查找树 看起来就是个奇葩
2结点就是普通的
3结点有两个键和对应的值 还有三条链接
左链指的键都小于该结点的两个键
右链就大
中链指的键介于该结点的两个键之间

向2结点中插入新键
先进行一次未命中的查找
把新结点挂在下面的话就不完美平衡了
所以可以跟刚刚那个2结点组成个3结点
三结点的插入就要复杂些 还要分情况

一棵只有3结点的树
插新键 一个3结点加个2结点
变成3个2结点
其实就是把3结点分了

给一个父结点为2结点的3结点插新键
把3结点的右边那个键丢到父结点上
跟父结点组成3结点
然后剩下的左键和新键分成两个2结点
父结点还是刚刚组成的那个3结点

给一个父节点为3结点的3结点插新键
之前有个细节我没管
其实3结点插新键有个辅助过程
就是形成个临时4结点
3个键 4个链接
然后应该把4结点的中键丢上去
所以不是丢右键 而应该丢中键
然后这个父结点为3结点的3结点
还是同样要组成临时4结点然后往父结点丢中键
但是父结点也是3结点啊
所以父结点要递归同样的过程
直到父结点是个2结点才OK
那么问题来了 如果一直到根结点都是3结点怎么办
新的情况就是要分解根结点
分解根结点很简单
根结点变成了临时的4结点然后分解成3个2结点
样子就是一棵简单的树
整个树的高会+1
但重要的是仍然保持了树的完美平衡性
这些操作都是为了保持完美平衡性
所以这些操作都不会往叶延伸
唯一会拓展的就是根分解
所以结点越加越多其实是根结点越来越往上走

红黑树
久仰大名 听着就挺吓人
用一些额外的信息来替换3结点的标准二叉查找树
树中的链接分成两种类型
黑链接就是普通链接
红链接是将两个2结点链接起来构成3结点
示意
3结点
ab
小于a 介于ab 大于b

红黑树
b
a(用红链接连接) 大于b（b的右链）
小于a 介于ab  （这两个分别是a的左链和右链）

所以
红链接都是左链接
没有一个结点同时有两条红链接
该树是完美黑色平衡 任意空链到根结点的路径上的黑链数量相同
把红链画平就很清晰了 跟2-3树一模一样
虽然概念很简单
但操作好尼玛复杂

旋转
这应该是个修复操作
假设有一条红色右链需要被转化为左链
这个操作叫左旋转
对应的方法接受一条指向某个结点的链接作为参数
假设这个被指向的结点的右链接是红色的
这个方法会进行调整并返回一个指向包含同一组键的子树
并且左链为红色的根结点的链接
旋转都有点看不懂 先放跳过 后面再细看


==========20190228===========
刷leetcode有道题
有一个数只出现一次 其他数会出现两次 找单独那个数
这题我用暴力解的
开个list 在里面就删掉 不在里面就丢进去
可想而知 速度非常慢
看了评论解答才发现 主流都用逻辑运算符
而我就算知道了这点 还是没想明白为什么可以这么做
其实也算查缺补漏 这种盲点说实话我真没在意过
然后发现真的是完全懵逼

逻辑运算符
& 位与 当两个操作位都是1时 结果位才为1
 | 有一个是1就是1
^ 只有一个是1时才是1
~ 操作数每个位都取反 得到操作数的二进制反码

那么问题来了 这个位是啥
好像是二进制
12是1100
10 是 1010

那么 刚刚那道题就可以用位异或运算符
所有成对的数字都会抵消
剩下那个就是单着的
这也太惨了

第一次知道leetcode ac过后可以从成绩表上点开看别人的代码

==========20190304===========
现在是我生日凌晨5点 睡不着 周一
八点左右打算请个假
这会睡了就估计中午才醒 请不了假了


==========20190313===========
红黑树性质
旋转
用两个键中的较小者作为根结点变为较大者作为根结点。
实现将一个红色左链接转换为一个红色右链接的右旋转代码完全相同，只用把left换成right就ok
早上半醒半睡得看书一点进度都没有
文字描述非常难懂
而图画非常清晰
两个结点（E,S）下面有三个部分 小于E 介于S与E之间 大于S
旋转就是要解决E和S的相对位置的问题 而跟下面三个部分无关
所以旋转不会动下面三个部分 而只会改变E和S的位置
例如
E结点 左链接为小于E 右链接为S结点
S结点 左链接为介于E与S之间 右链接为大于S
旋转后
S结点左链接为E结点 右链接为大于S
E结点 左结点为小于E 右结点为介于E与S之间

右旋同理
有点忘掉红黑树的性质了
红链是2-3结点的另一种表示方式 更朴素 概念更少 更剃刀
红链所指的结点的右链表示 介于红链起始结点和指向结点之间的子树
1.红链接都是左链
2.没有任何一个结点同时和两条红链相连
3.红黑树是完美黑色平衡的 即任何空链接到根结点的路径上的黑链接数量相同

向2结点插新键
如果新键小于老键 就单纯新增一个红色结点就好
如果新键大于老键 新增的红色结点会产生一条红色的右链接 这时候用左旋来修正
两种情况的结果都会是一样的 都是符合红黑树的性质

向树底部的2结点插入新键
同样 小于父结点就直接成一个三结点
大于父结点就需要左旋修正错误的红色右链

向3结点插入新键
右链接 直接换颜色
左链接 先右旋然后换颜色
中链接 先左旋下层链接 然后右旋上层链接 再换颜色

http://www.360doc.com/content/15/0810/11/26127157_490695847.shtml

==========20190318===========
周六面试总结及近期安排

那个面试 笔试方面基本上没问题 倒数第二道题应该做错了 
一对兔子 从第三个月开始每一个月可以生一对兔子 假设不会死亡
问给定几个月后会有多少对兔子
这题我写的时候想得有点急 写出来感觉有点问题 细想了一下好像是对的就交了 等会重新做一遍
还有transfrom.position.x不能直接改的原因我就写了transfrom.position是个vector3
出来查了一下好像并没有说到问题的本质 还需复盘
做完了就面试 一哥们还现查面试题 跟上课玩手机一样放桌子下面看
不过一共五六道题我没答上来几道....
stringbuilder跟string的区别 我就知道对string操作多了就该用stringbuilder 其他都不了解了 也就直说不了解了
装箱拆箱 这个我也没答上来 当时大脑短路 感觉跟快问快答一样 不会的就先跳了 没想到后面的问题更不会
但装箱拆箱当我走出楼我就想起来 这东西就是值类型跟引用类型的转换 等会好好看看书 不应该啊兄弟
网络解包 这个硬生生的不会 没办法
drawcall 这个也是硬生生的不会
assestbundle同理。。。。
这三个东西感觉都能很快掌握 可能网络这个可以深入很多 毕竟网络这本身就是门大课 当然实际用的时候还是一样的行活
就算不太了解也可以按套路按框架按别人写的自己模仿个大概能用
drawcall和assestbundle都应该是纯粹的行活吧 应该不难 短时间内就能掌握

另一个哥们给我说简历有些地方可以写细一点
拼界面接数据这个太粗略了 讲一下具体做了什么 完成了什么效果
很有道理 我这些表面活又不上心又期望对方不在意 要不得

这段时间的安排是
先把这次面试的复盘做了 
然后看看书 橙皮算法搞完 网络开始看
网络解包 drawcall assestbundle 这三个都是行活 我之前也有下unity的视频 那里面应该有讲
视频课应该很快能搞完
大概一周吧 开始重新找工作 这次要求高一点 六七千的水平
看书还是扎实一点 他妈的装箱拆箱都答不上来 该挨

开搞
首先是装箱拆箱
这跟结构有关
结构体笔试也问了 问结构跟类有啥区别 我就写了个类能有方法
但这会看书发现不止这个
结构是不能赋初始值的
我的理解 因为结构本身是定义的一组数据的类型 是抽象的
赋初始值是结构的实体才能做的
这里有写到类的直接定义的字段成员
类的成员变量声明的时候可以直接初始化
但在C#编译器编译这段代码为程序集时
成员变量就只有声明
初始化的赋值被（自动）放到构造函数里了
所以其实类的字段也不能有初始值 但这就算微软的语法糖吧
好像类和结构体的区别就这两个
哦 结构总是隐式密封的 所以 不能从结构派生其他结构
回到装箱拆箱


==========20190320===========
拆箱装箱
讲一个结构实例作为引用类型对象 就必须创建装箱的副本
装箱的过程就是制作值类型变量的引用类型副本
值类型在内的所有C#类型都派生自object类型 而值类型是高效轻量的类型
因为默认情况下在堆上不包括他们的对象组件 然而如果需要对象组件就可以用装箱
装箱是一种隐式转换 接受值类型的值 并根据这个值在堆上创建一个完整的引用类型对象并返回对象引用

int i = 12;
object oi = null;
oi = i;

这就完成了装箱
而且oi 和 i是互相独立的
装箱时返回引用类型的副本

int i = 10;
object oi = i;
Console.WriteLine("i:{0}, oi:{1}",i,oi);
输出为(10 10)
i = 12;
oi = 15;
Console.WriteLine("i:{0}, oi:{1}",i,oi);
输出为（12 15）

拆箱就是 int j = (int)oi;
没啥说的
尝试将一个值拆箱为非原始类型时会抛出异常 InvalidCastException

string 和 stringbuilder
1.字符串是Unicode字符数组
2.字符串是不可变的（immutable）-它们不能被修改
对string 任何“改变”都会分配一个新的恒定字符串
string a = "aaa"; 
a.ToUpper();
Console.WriteLine(a);
输出："aaa"

stringbuilder类可以动态有效地生成字符串 避免创建许多副本
1.StringBUilder类是BCL的成员 位与System.Text命名空间中
BCL是啥....
查了一下好像是Base Class Library 基类库
还有FCL Framework Class Library类库
FCL中的其他类基本上引用BCL在其基础上做的扩充
2.StringBuilder对象是Unicode字符的可变数组
方便使用string而已 没啥其他特别的



==========20190321===========
开始正式看网络了
计算机网络 Tanenbaum 和 Wetherall写的
还尼玛全英文 从来没看过英文教材 英文的火星救援就看了几页
走着



==========20190402===========
正则表达式
Regular Expression
专门处理字符串处理
也是字符串 由普通字符和特殊字符构成


==========20190411===========
前几天成都这边一个不算小的厂的笔试我没过
问的问题感觉都还挺有难度的 跟一般的小厂不是一个等级
C#和unity的知识我还有很多漏洞
也反映了我最近确实非常懈怠
不应该这样子啊
最近机会也比较少
那天还有另外一场面试
不过感觉面试那人的水平有些问题
我确实有些部分不太了解 但做过的都没问题啊
问canvas的作用是什么 这问题。。。。。不就是画ui吗 还能有什么作用
还问我滑块怎么归零 我回答了他说没有scrollbar这个组件
感觉可能他没咋用过ugui 然后拿ngui那套在考我
总之莫名其妙的整场我也搞不懂他的问题是什么意思有什么意义 我的回答他也觉得不满意 奇怪得一笔
那个大厂占了一整层楼 应该算大厂了吧 笔试的题确实大部分我都不能回答得很完美
过段时间复盘吧 今天先看看书 那么大片的东西我不太清楚 说明不是某些点不知道
而是一整块知识都不清楚 所以看书才是对的 复盘补具体的题太片面了



==========20190412===========
今天开始每天定量看书 4个小时 暂定
目前先搞unity这块 ugui assetbundle drawcall优化这些
面试问的多 我之前也没太在意 先看

ugui 看的应该比较快 需要注意的地方再写一下记一下
raycast target一般没必要不要勾选 ugui的事件系统会遍历所有带raycasttarget的组件
会带来一些没必要的开销 而且还不是很小
但ugui默认是都会勾选的 所以之前也做过 重写一下 默认不勾选

描边和阴影 Outline Shadow
描边的原理是在text组件上下左右各多画一边 所以效率比较低
而阴影就会好些 只需多画一边 所以能用阴影就不要用描边

image
四种格式
simple 直接显示
sliced 九宫格 可用SpriteEditor编辑
tiled 平铺
filled 像技能cd一样 可旋转图片

Raw Image
Image组件只能显示Sprite
而Raw Image既可以显示任意Texture
(我一直分不清纹理和材质 材质球什么的一直不懂)
也可以显示Sprite 只不过还是以Texture方式显示的
每一个Raw Image就占一次DrawCall 所以不太建议使用

==========20190413===========
 按钮 单选toggle 滑动条这些就不说了 本来就没啥内容
ScrollRect 滑动矩形 也就是滑动条的二维版本
拿来做摇杆算最典型的用法

canvas作用还是不太知道上次那个面试想要问我什么东西 不就是放ui吗 还能干什么
布局组件 
上次面试也问到我比如背包系统 排东西怎么排 我是动态的直接写在哪哪哪个位置 坐标一个一个排出来
面试官给我说可以用布局什么东西自动搞 应该就是这个布局组件

Atlas 图集
之前打过图集 也是一个有经验就好的事情 没啥太多为什么 用的时候学一学 不是理论方面的

canvas优化
ugui会自动合并批次 一个canvas的所有元素会合并到一个mesh里 任意一个改动就要重新合并所有元素的mesh
所以比较好的做法是 每一个UI界面都设置成一个Canvas 甚至如果一个界面下的元素比较多 可以考虑多套几个canvas 尤其是需要频繁改变的元素
这样可以降低合并mesh的开销 然而 canvas太多也不好 drawcall会上升 因为每一个canvas会单独占用一个drawcall
打图集也是为了降低drawcall 每一个贴图会多占用一个drawcall 打图集就是把多张图片合并到一起 这样减少drawcall
不是所有图片都适合使用图集 比如图标资源 几千个图标放一个图集里 而游戏中又只需要同时显示少部分的图标 而整个图集都会被载入到内存里
图标的出现率又很高 那么这么大的图集内存就几乎没有机会释放 所以这种图标就不太适合使用图集

书后面关于ugui还有很多内容 但不是基础 而是使用的时候一些常见可优化的点以及具体实现 我目前看不太明白 就先跳过了 之后工作上遇到了再回看
momo这书是真的好 ugui看过了 我准备看assetbundle那些 也就是资源加载 
但看了眼目录 其实很多东西我还特别应该看 比如动画 比如读数据部分 Excel操作这些 都是非常实用而且肯定要学 
面试里也很可能被问到 我不应该像之前一样人家问了 我就说 啊 不好意思 我还不会 会的越多就是离合格的程序员越近 也就越可能拿到工作
图形学那些 shader啊 管线啊 都是大工程 这些东西应该先看 看了肯定有用 会了肯定加分 走着
先看 资源加载

.meta文件必须进行版本控制
这东西是相当于资源视图中的参数 不传的话 别人虽然拿到了资源 但设置不正确 会出现问题

多工程 用导出包导入就好

Resources文件夹是标志性的目录 这里面的资源无论是否被引用都会强制打在游戏包里
这文件夹可以是顶层目录 也可以是某个文件夹的子目录 打包后Unity会自动合并
Resources目录下的资源最好不要直接引用在场景中 不然会被场景和resources打成两份

AssetBundle还是网游用的
StreamingAssets就是拿来放下载的AssetBundle资源


==========20190415===========
unity 文件夹作用

Assets 游戏资源的顶层文件夹
Editor 编辑模式下的代码放这里 打包之后会自动剥离
Editor Default Resources 编辑模式下的资源尽量放这里
Gizmos 放一些工具类图标
Plugins 会优先编译成DLL文件
Resources 此目录下所有资源都会自动构建在包体内
Standard Assets 导入unity标准资源的package文件夹 这里的脚本会比较优先得执行
StreamingAssets AssetBundle文件适合放在这里 因为这里的资源不会被自动压缩或者改变

大小包 小包需要额外下载才完整 大包就是完整包 大小包可以用隐藏文件夹 具体暂略


==========20190416===========
最早一次笔试 有一道题是C#的继承方面的 很绕
关键有一点 构造函数后面跟 :base()
我一直没找到 也没特别仔细的找 这是啥 我也一直不太清楚
今天终于大概找到该看哪里了 之前以为是类里面的方法都可以继承其他方法
关键字是 构造函数的初始化语句
这是关于构造函数的 不是随便一个方法的 所以之前没找到也是很正常 因为不存在什么 方法的继承
简而言之 用base是指要调用基类的构造函数
而用this 是指要调用当前类的构造函数
当然参数是要匹配的

(
今天还有一道笔试题我就完全写不了 override和overload有啥区别
我心想 override我知道是啥 overload我是真的想不到这是指的啥
看了书才发现 这是尼玛指的这个东西
函数名一样参数不一样 就是overload 方法的重载
实际上为啥我几乎想不起来这个知识点
是因为 在我的脑海里 函数的标识也就是唯一性 是来自于 函数名以及参数 其中参数指的是 函数的参数的个数 参数的类型 以及 多个参数的具体顺序
这些全部一样之后 才可以说 这俩个函数是一样的 (返回值类型不在其中 提醒) 或者说这两个函数冲突了
所以 其实重载这个词 没有啥具体特别的意义 没有它是一样的 这不是一个基础概念 
)

==========20190505===========
重新看一遍C#书 再完整看一遍U3d书

C#关键字里发现了一堆完全不知道用法的关键字
checked decimal explicit fixed goto implicit 
lock operator params readonly stackalloc 
unchecked unsafe volatile


==========20190514===========
还是看看u3d书上关于资源加载的部分
GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>("Assets/Cube.prefab");

//方式1
GameObject go = GameObject.Instantiate<GameObject>(prefab);
//GameObject.Instantiate只创建新对象 会丢失Prefab的引用

//方式2
GameObject go = PrefabUtility.InstantiatePrefab(prefab) as GameObject;
//PrefabUtility.InstantiatePrefab方法会保持原有的引用关系

看了半天这是编辑模式的操作 运行模式就不能这么写 打了包就不会带上editor文件夹里的东西
所以这些操作都是写给工具用的
面试的时候考的资源加载和卸载 肯定不是关注编辑模式的

==========20190519===========
明早有个面试
在这里要检讨一下
本来是15号下午接到的电话 打算周五面 但人家没时间
就推到了周一
不算15号都有整整4天 然而打p5就花了3天
最后一天也就是今天还在疯狂拖延
这不就打算通宵准备准备 一早去面试
该挨

开搞

运行模式下的资源加载卸载内容
Resource.Load<T>("name");
Resource目录下的资源都会打包 所以不必要加载的以及废弃的 就不要放进去

另外Resource目录下的资源不要直接引用在场景中 否则会被场景和resource打成两份
这句话不是很明白 啥叫直接引用

删除对象
GameObject.Destroy()
GameObject.DestroyImmediate()
第一个会等一帧再彻底删除 因为这一帧后面可能有其他地方在操作这个对象 一般建议使用
第二个会立即删除 所以执行后如果有其他地方代码操作被删的对象就会立即报错

/*
//一秒后删除
GameObject.Destroy(go, 1f)
*/

对象删了但资源还没删 资源仍在内存里
Resources.UnloadAsset()
Resources.UnloadUnusedAssets()
删除资源是异步操作 可以使用 isDone (bool)来判断是否完成

调用两遍GC() 和 Resources.UnloadAsset() 来保证C#完成GC工作

AssetBundle
加载
AssetBundle ab = AssetBundle.LoadFromFile(path)
//加载manifest 加载依赖的bundle

读取
ab.LoadAsset<T>(name);
实例化
GameObject.Instantiate<T>(go);

加载场景就加载了场景Bundle后直接SceneManager.LoadScene(name);

卸载AssetBundle
加载过程 AssetBundle对象 > 资源对象 >游戏对象
卸载就过程反过来
GameObject.Destroy()
Resources.UnloadUnusedAssets()
AssetBundle.UnloadAllAssetBundles(true)



==========20190525===========
图
貌似比想象中要简单
点和边而已
当然现在我刚开始看这部分

==========20190530===========
T0目前基本掌握--------------------------ugui 算法和数据结构 C# 
T1 马上学习并且短期内能掌握的----------热更新 assetsbundle lua json/xml/excel数据解析
T2 要学习但不是短期内能掌握的----------shader 图形学 网络 Java&Android C++
T3 计算机基础部分但工作上用的少--------操作系统 编译原理


把目前该学的分了个优先级
首先T0部分 算是基本掌握 但有漏洞有疏漏就应该第一时间补 这部分应该是最核心的


不知道该不该写的 MVC SVN Navigation导航系统
不知道啥东西的 FSM状态机 物理引擎 行为树 遮挡剔除 LOD 光照贴图 对象池
A*算法 

==========20190531===========
图
貌似比想象中要简单
点和边而已
当然现在我刚开始看这部分

==========20190609===========
持久化数据


