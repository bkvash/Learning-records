继续哈希表
感觉重要的就是哈希函数
就像一个洒水器 尽量把数据均匀的洒在存储空间上 这样 即使冲突了 冲突项也不会太多
合理的使用了存储空间 关键就是这个 怎么洒 也就是哈希函数
三个散列函数 前两个都看懂了 最后一个 没太懂 大概了解
第三个是多项式 有点像级数 应该是想填满储存空间吧 让哈希值尽量散开 有种撒大网的感觉

应对冲突的方法 有两种最简单
第一种 分离链接法
就是冲突的建个表 冲突了就把新的接到表上
找也是先找到表 然后在表里找
具体代码看不太明白 涉及到指针什么的 C还是不像C#那样简单

另一种叫开放定址法
就不解决冲突 冲突了就换另外的单元 知道找到空单元为止
后面的略了 简单的面试题水平点到为止

优先队列（堆） 题目叫这个
priority queue
优先队列和堆看题目好像是一个东西 百度了一下好像又不太一样
这句话让我有些懵逼 
堆（heap）是一种重要的数据结构，是实现优先队列（Priority Queues）首选的数据结构
em.......
堆是数据结构的话 那优先队列是什么东西呢
我以为我一直在学的就是数据结构 没想到还有一层新的概念
ADT 抽象数据类型 之前看了没在意
似乎 ADT是比数据结构更基础的
知乎里搜了搜 数据结构是ADT提供的规范的具体实现
大概明白了些 这种问题学着学着就清晰了

优先队列两个基本操作 Insert插入 DeleteMin删除最小者
DM的工作就是找出、返回和删除优先队列中的最小元素
插入等同于入队 DM就等同于出队
操作系统里会用到 大概是一堆任务里选最简单的来做这种思路吧 记得之前有个讲时间管理的视频提过
还有贪婪算法 也是之前听过的 大概是追求短期目标最优解的意思
优先队列的实现方法
第一种 很简单直接 在链表表头以O(1)执行插入操作 然后遍历整个链表删除最小元 O(N)
另一种是 让表保持排序状态 插入代价高昂O(N) 而DM代价低O(1)
相比之下 第一种好 因为 插入操作通常比Dm多
还有一种是用二叉查找树 两种操作都是平均O(logN)
不过如果反复删除左子树的节点 会损害树的平衡 最坏的情况 把左子树删空
右子树的元素最多是它应有的两倍 不过也是加个小常数的事
可以通过平衡树 把界变成最坏情况的界 防止出现坏的插入序列  这句话每台明白 主要之前树都不是特别仔细的看

二叉堆
是应该用的 一般堆这个词不加修饰就是指的二叉堆的实现

后面全是树 感觉可以回头了
后面的章节就是排序 进入算法部分了 还有个图论 貌似也不是数据结构
那么就开始细看了 做题 每个地方都要一个一个搞明白了
估计要个几天 然后进入算法部分 基本的排序这些
总共应该半个月吧 当然这只是数据结构与算法这些简答的部分 什么图论 红黑树 动态规划 就暂放着
先把简单的搞定

哎
十年前我有机会学这些东西的
学了之后我觉得应该不会像现在这样窘迫了吧