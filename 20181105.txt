明天有个面试 hr给我吹的加拿大海归主程要求有些严 害怕我通不过
我表示给个机会
害怕让我来害怕 要求严我也一时没法补完
今天打算看完c# 异步 异常 反射
linq暂放

异步
进程和线程
进程是构成运行程序的资源的集合 线程代表真正执行的程序
不是很懂
目前接触到的都是一个程序使用一个线程
但这种简单的模型并不实用
异步就是让程序不需要按照编写时的顺序严格执行
不让程序等待响应 而是在等待的同时执行其他任务 然后回复到达后再执行原来的任务
大概是说跟服务器请求数据这种事 传数据挺耗时间的 程序不应该停在这等
异步先略过 看了一下 不是两下解决的事情 而且目前没有需求

命名空间和程序集
之前浅略的了解了一下 目前也够用 暂略

异常
感觉是无比有用的部分
找bug改bug可能是职业生涯的永恒的主题 程序员职业生涯的意义之一
try catch finally
还没细看书 大概了解
先执行try 若里面有问题
就不执行try 改执行catch
最后不管有没有问题都要执行 finally
异常类
有系统异常 预定义的 估计也是致命的
还有应用程序定义的异常 非致命的 自定义的
catch子句有三种形式 
第一种不带参数 就是匹配try中任何类型的异常
第二种 带个异常类型 匹配该类型的....
第三种 带异常类型和异常变量 就是匹配具体异常变量的
对了 匹配异常都是指定类及派生

第三种我好像理解错了 带的异常变量是clr创建的异常对象的应用 
也就是说可以在catch里访问这个异常变量 可以获得更多引起的变量的详细信息
有意思
catch子句可以用多个 那么就有哪个放前面哪个放后面的问题
那当然是最明确的最特殊的最特别的放第一个
最普遍的放最后
比如一般catch句 就是不带参数的 那肯定该放最后一个 要不然第一个触发会挡掉后面的更细的catch子句
即使catch里有错误 finally都会执行
突然想起之前有谁提到trycatch的滥用 现在一想这不应该滥用吗
滥用这个不是应该的吗
异常处理流程简略看了一下 finally之后在try块后面继续执行
throw 可以引发异常 具体也粗略看了下 略了

反射
重头戏来了
有关程序及其类型的数据叫 元数据 metadata
查看元数据的行为叫 反射 reflection
type类
貌似是类型的类型
type类包含类型的特性 使用这个类的对象能获取程序使用的类型的信息
平常经常见的方法 GetType()

特性
大概讲了十几页 今天不看了 肯定是脑壳疼的那种东西